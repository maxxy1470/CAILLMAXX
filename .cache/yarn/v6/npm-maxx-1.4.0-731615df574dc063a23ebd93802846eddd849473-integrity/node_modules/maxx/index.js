#! /usr/bin/env node

const util = require("./util");
const bar = util.bar;
const findEnvFile = util.findEnvFile;
const config = require("./config");
const chalk = require("chalk");
const program = require("commander");
const fs = require("fs");
const yaml = require("yaml");
const prompt = require("prompt-sync")({ sigint: true });
const wfm = require("./wfm");
const tmp = require("tmp");
const datefns = require("date-fns");
const { spawnSync } = require("child_process");

const doJob = require("./getJob");

const sevColors = ["blue", "green", "orange", "red"];

const defaultMemo = `


# Enter your notes for the time.
# Lines prefixed with # are ignored and the file is truncated for whitespace at either end.
# Save the file and exit the editor when done.
`;

const announce = (what, sev = 0) =>
  console.log(chalk[sevColors[sev]](":: ") + chalk.bold(what));

const checkConfig = () => {
  if (config.exists()) {
    config.load();
  }

  const requiredValues = ["WFM_APIKEY", "WFM_ACCOUNTKEY"];

  if (requiredValues.some(x => config.get(x) == null)) {
    announce("Your configuration is missing or incomplete", 3);
    announce("Enter the required credentials", 3);

    requiredValues
      .filter(x => config.get(x) == null)
      .map(x => [x, prompt(x + ": ")])
      .forEach(x => config.put(...x));

    config.save();
  }
};

const jobNumsFromYaml = () => {
  const yamlText = findEnvFile();

  if (yamlText == null) {
    announce("project.yaml not found in this or and parent directories", 3);
    return [];
  } else {
    try {
      const project = yaml.parse(yamlText);
      return project.activeJobs;
    } catch (err) {
      announce("Error parsing project.yaml", 3);
      return [];
    }
  }
};

const validateJobNum = num => /^J\d{6}$/i.test(num);

program
  .command("add-time <amount>")
  .option("-j, --job <jobNum>")
  .option("-m, --memo <memo>")
  .option("-d, --dryrun")
  .action(async function(amount, cmd) {
    checkConfig();

    let jobNum = cmd.job;

    if (jobNum == null) {
      announce("Job number not provided. Searching environment");
      const jobs = jobNumsFromYaml();
      if (jobs.length === 0) {
        announce("No job numbers found", 3);
        return;
      } else {
        jobNum = jobs[0].trim();
      }
    }

    if (!validateJobNum(jobNum)) {
      announce(`The job number ${jobNum} is formatted incorrectly.`, 3);
      return;
    }

    announce("Using job number: " + chalk.blue(jobNum), 1);

    let userId = config.get("USER_ID");

    if (userId == null) {
      announce("Your configuration is missing or incomplete", 3);
      const email = prompt("Enter your email address: ");
      announce("Getting user data...");
      const users = await wfm.get("/staff.api/list");
      const user = users.Response.StaffList[0].Staff.map(x => ({
        id: x.ID[0],
        name: x.Name[0],
        email: x.Email[0]
      })).find(
        x =>
          x.email.trim().toLocaleLowerCase() ===
          email.trim().toLocaleLowerCase()
      );
      if (user == null) {
        announce("No user exists. Blame admin.", 3);
        return;
      } else if (
        prompt(`Are you ${user.name}? (Y/n)`)
          .trim()
          .toLocaleLowerCase() === "n"
      ) {
        announce("Invalid email address. Blame admin", 3);
        return;
      } else {
        config.put("USER_ID", user.id);
        config.put("USER_EMAIL", user.email);
        userId = user.id;
        config.save();
        announce("Config saved.");
      }
    }

    const job = await wfm.get(`/job.api/get/${jobNum}`);

    const tasks = job.Response.Job[0].Tasks[0].Task.map(x => ({
      id: x.ID[0],
      name: x.Name[0],
      assigned: x.Assigned == null ? null : x.Assigned[0].Staff[0]
    }));

    const defaultIndex = tasks.findIndex(x =>
      x.name.toLocaleLowerCase().includes("development")
    );

    const jobName = job.Response.Job[0].Name[0];

    announce(`Job is: ${chalk.blue(job.Response.Job[0].Name[0])}`);

    console.log("");

    console.log(
      tasks
        .map((x, i) => `  ${chalk.blue("(" + (i + 1) + ")")} - ${x.name}`)
        .join("\n")
    );

    console.log("");

    const taskIndex =
      parseInt(
        prompt(
          defaultIndex > -1
            ? `Select Task (${defaultIndex + 1}): `
            : "Select Task: "
        ),
        10
      ) || defaultIndex + 1;

    if (Number.isNaN(taskIndex) || tasks[taskIndex - 1] == null) {
      announce("Not a valid index. Exiting", 3);
      return;
    }

    console.log("");

    const taskId = tasks[taskIndex - 1].id;

    let notes = cmd.memo;

    if (notes == null) {
      const file = tmp.fileSync();
      fs.writeFileSync(file.name, defaultMemo);
      spawnSync("nano", [file.name], {
        stdio: "inherit",
        detached: true
      });
      const noteData = fs
        .readFileSync(file.name, "utf8")
        .split("\n")
        .map(x => x.trim())
        .filter(x => !x.startsWith("#"));
      if (noteData.length === 0) {
        announce("No notes given", 3);
        return;
      } else {
        notes = noteData.join("\n").trim();
      }
    }

    // todo use a lib for this
    const postData = `<Timesheet>
                        <Job>${jobNum}</Job> 
                        <Task>${taskId}</Task> 
                        <Staff>${userId}</Staff> 
                        <Date>${datefns.format(new Date(), "YYYYMMDD")}</Date> 
                        <Minutes>${amount * 60}</Minutes> 
                        <Note>${notes}</Note>
                      </Timesheet>`;

    const summary = [
      ["Job", jobName],
      ["Task", tasks[taskIndex - 1].name],
      [
        "Time",
        `${amount} hour${amount !== 1 ? "s" : ""} or ${amount * 60} minutes.`
      ],
      ["On date", datefns.format(new Date(), "YYYY-MM-DD")],
      ["With notes", notes]
    ]
      .map(x => `  ${chalk.bold(x[0])}: ${chalk.blue(x[1])}`)
      .join("\n");

    console.log(summary);
    console.log("");

    if (cmd.dryrun) {
      announce("Data not posted. Dry run");
    } else {
      const contin =
        prompt("Is this correct? (y/N): ").toLocaleLowerCase() === "y";

      if (!contin) {
        announce("No action taken.");
        return;
      }

      const res = await wfm.post("/time.api/add", postData);
      if (res.Response.Status[0] === "ERROR") {
        announce(`Error from WFM: ${res.Response.ErrorDescription[0]}`, 3);
        return;
      } else {
        announce("Posting successful.");
      }
    }
  });

program.command("job [jobNums...]").action(async function(jobNums) {
  checkConfig();

  let usingProjectYaml = false;

  if (jobNums.length === 0) {
    announce("Job number not provided. Searching environment");
    jobNums = jobNumsFromYaml();
  }

  if (jobNums.length === 0) {
    announce("No job numbers found", 3);
    return;
  }

  jobNums = jobNums.map(x => x.trim());

  if (!jobNums.every(validateJobNum)) {
    announce("Some job numbers are incorrectly formatted.", 3);
    if (usingProjectYaml) {
      announce("Check your project.yaml file", 3);
    }
    return;
  }

  announce("Using job numbers: " + chalk.blue(jobNums.join(", ")), 1);
  announce("Fetching...", 1);

  const jobs = await Promise.all(jobNums.map(doJob));

  const hourlyRate = (budget, tasks) =>
    budget /
    (tasks
      .filter(x => x.billable)
      .reduce((acc, val) => acc + val.usedMinutes, 0) /
      60);

  jobs.forEach(job => {
    console.log();
    console.log(
      chalk.bold(chalk.blue(job.jobId) + " - " + job.name + " - " + job.state)
    );
    if (typeof job.budget == "number") {
      console.log(chalk.bold("Budget:") + " £" + job.budget.toLocaleString());

      const rate = hourlyRate(job.budget, job.tasks);

      console.log(
        chalk.bold("Effective Hourly Rate (EHR):") +
          chalk[rate > 100 ? "green" : "red"](" £" + rate.toFixed(2))
      );
    } else {
      console.log(chalk.bold("Budget:") + chalk.red(" None given!"));

      console.log(
        chalk.bold("Effective Hourly Rate (EHR):") +
          chalk.red(" No budget given.")
      );
    }

    console.log();
    if (job.tasks.length === 0) {
      announce("No tasks in job", 3);
    }

    job.tasks.forEach(x => {
      console.log(x.name + (x.billable ? " (Billable)" : ""));
      console.log(bar(x.usedMinutes, x.budget));
      console.log();
    });
  });
});

program.parse(process.argv);
